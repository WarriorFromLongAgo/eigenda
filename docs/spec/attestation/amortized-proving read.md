这个文件的主要内容是关于KZG-FFT编码器后端的实现，特别是其中的分摊KZG证明生成过程。以下是文件的主要内容概述，翻译成中文：
KZG-FFT编码器后端实现
文件描述了KZG-FFT编码器后端如何实现Encode接口，该接口将数据blob转换为一系列的Chunks，并生成相关的多项式承诺和证明。
多项式系数和承诺的推导
文件解释了如何将数据blob转换为多项式表示，并计算KZG承诺。
使用FFT进行多项式求值
文档详细说明了如何使用离散傅里叶变换（DFT）来高效地评估多项式。它解释了循环群的概念，以及如何使用DFT和逆DFT在多项式系数和多项式求值之间进行转换。
4. 使用FFT进行分摊多重揭示证明生成
文件描述了如何使用DFT生成分摊的多重揭示证明。它解释了陪集的概念，以及如何使用陪集来组织多项式求值的索引。
编码接口的额外约束
文件强调了由于使用FFT而产生的额外约束，特别是关于NumChunks和ChunkLength需要是2的幂。
实例说明
文件最后提供了一个具体的例子，说明了如何根据给定的参数（ChunkLength和NumChunks）分配索引。
总的来说，这个文档深入解释了KZG-FFT编码器后端的工作原理，特别强调了如何利用FFT来实现高效的多项式操作和证明生成。



以下是文档的中文翻译：

# 分摊KZG证明后端

重要的是，编码和承诺任务能够在几秒钟内完成，且计算的主导复杂度几乎与多项式的度呈线性关系。这是通过基于快速傅里叶变换（FFT）的算法实现的。

本文档描述了KZG-FFT编码器后端如何实现`Encode(data [][]byte, params EncodingParams) (BlobCommitments, []*Chunk, error)`接口，该接口1）将blob转换为`params.NumChunks`个`Chunks`的列表，每个chunk长度为`params.ChunkLength`；2）生成相关的多项式承诺和证明。

我们还将强调由KZG-FFT编码器后端引起的编码接口的额外约束。

## 推导多项式系数和承诺

如[编码模块规范](../spec/protocol-modules/storage/encoding.md)所述，给定一个数据blob，我们通过简单地将数据切片成符号串，并将这个符号列表解释为元组$(c_i)_{i=0}^{m-1}$，将blob转换为多项式$p(X) = \sum_{i=0}^{m-1} c_iX^i$。

对于KZG-FFT编码器，多项式位于与BN254椭圆曲线相关的域上，其阶为[待填写阶数]。

给定这种多项式表示，可以按照[KZG多项式承诺](https://dankradfeist.de/ethereum/2020/06/16/kate-polynomial-commitments.html)中的方法计算KZG承诺。

## 使用FFT进行多项式求值

为了使用离散傅里叶变换（DFT）来评估多项式，构成Chunks的多项式求值的索引必须是循环群的成员，我们称之为$S$。循环群是通过取某个生成元$v$的所有整数幂生成的群，即$\{v^k | k \in \mathbb{Z} \}$（因此，阶为$|S|=m$的循环群$S$的元素有时被称为$|m|$次单位根）。注意，由于我们的多项式位于BN254域上，群$S$必须是该域的子群（即其所有元素必须位于该域内）。

给定阶为$m$的循环群$S$，我们可以通过DFT在$S$中包含的索引处评估阶为$n$的多项式$p(X)$：

$$
p_k = \sum_{i=1}^{n}c_i (v^k)^i
$$

其中$p_k$给出了多项式在$v^k \in S$处的求值。令$c$表示多项式系数向量，$p$表示多项式求值向量，我们可以使用简写$p = DFT[c]$。逆关系也成立，即$c = DFT^{-1}[p]$。

为了以编程方式评估DFT，我们希望$m = n$。注意，当$m > n$时，我们可以通过简单地用零填充$c$使其长度为$m$来实现这一点。

FFT的使用可能对群$S$的大小提出额外要求。在我们的实现中，我们要求$S$的大小为2的幂。为此，我们可以利用与BN254相关的素数域包含一个阶为$2^{28}$的子群的事实，该子群又包含阶跨越小于$2^{28}$的每个2的幂的子群。

由于编码接口要求构造`NumChunks`个长度为`ChunkLength`的Chunks，我们的应用要求$S$的大小为`NumChunks*ChunkLength`，而这反过来必须是2的幂。

## 使用FFT进行分摊多重揭示证明生成

多重揭示证明的构造也可以使用DFT来执行（如["快速分摊Kate证明"](https://eprint.iacr.org/2023/033.pdf)中所述）。将此过程的完整细节留给参考文档，我们在这里只描述1）分摊多重证明生成方法使用的索引分配方案，以及2）这为整体编码器接口创造的约束。

给定对应于多项式求值索引的群$S$和作为$S$子群的循环群$C$，$C$在$S$中的陪集由以下给出：

$$
s+C = \{g+c : c \in C\} \text{ for } s \in S.
$$

每个陪集$s+C$的大小为$|C|$，并且有$|S|/|C|$个唯一且不相交的陪集。

给定多项式$p(X)$和群$S$和$C$，分摊Kate证明方法生成$|S|/|C|$个不同的KZG多重揭示证明，其中每个证明与$p(X)$在单个陪集$sC$（对于$s \in S$）中包含的索引处的求值相关联。因为分摊Kate证明方法在底层使用FFT，$C$本身的阶必须是2的幂。

对于KZG-FFT编码器而言，这意味着我们必须选择$S$的大小为`NumChunks*ChunkLength`，$C$的大小为`ChunkLength`，每个都必须是2的幂。

## 工作示例

作为一个简单的说明性示例，假设`AssignmentCoordinator`为了满足给定blob的安全要求提供以下参数：
- `ChunkLength` = 3
- `NumChunks` = 4

提供这些参数后，`Encoder.ParamsFromMins`将`ChunkLength`升级到下一个最高的2的幂，即`ChunkLength` = 4，并保持`NumChunks`不变。下图说明了在这种情况下索引如何在chunks之间分配。

![ChunkLength=4, NumChunks=4的chunk索引工作示例](../../assets/encoding-groups.png)
